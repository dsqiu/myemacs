;;; Compiled snippets and support files for `popup-el'
;;; Snippet definitions:
;;;
(yas-define-snippets 'popup-el
		     '(("Cask" "(source gnu)\n(source melpa)\n\n(package-file \"popup.el\")\n\n(development\n (depends-on \"ert\"))\n" "Cask" nil nil nil nil nil nil)
		       ("Makefile" "EMACS ?= emacs\nCASK ?= cask\nEMACS23=emacs23\n\nELPA_DIR = \\\n	.cask/$(shell $(EMACS) -Q --batch --eval '(princ emacs-version)')/elpa\n\n.PHONY: test test-nw test-emacs23 test-emacs23-nw travis-ci\n\ntest:\n	$(CASK) exec $(EMACS) -Q -L . -l tests/run-test.el\n\ntest-nw:\n	$(CASK) exec $(EMACS) -Q -nw -L . -l tests/run-test.el\n\ntest-emacs23: tests/ert.el\n	${EMACS23} -Q -L . -l test/ert.el -l tests/run-test.el\n\ntest-emacs23-nw: tests/ert.el\n	$(EMACS23) -Q -nw -L . -l test/ert.el -l tests/run-test.el\n\ntravis-ci: elpa\n	$(CASK) exec $(EMACS) -batch -Q -l tests/run-test.el\n\nelpa: $(ELPA_DIR)\n$(ELPA_DIR): Cask\n	$(CASK) install\n	touch $@\n" "Makefile" nil nil nil nil nil nil)
		       ("README.md" "popup.el\n========\n\n[![Build Status](https://secure.travis-ci.org/auto-complete/popup-el.png)](http://travis-ci.org/auto-complete/popup-el)\n\nOverview\n--------\n\npopup.el is a visual popup user interface library for Emacs. This\nprovides a basic API and common UI widgets such as popup tooltips and\npopup menus.\n\nScreenshots\n-----------\n\n**Tooltip**\n\n![](http://cx4a.org/software/popup/popup1.png)\n\n**Popup Menu**\n\n![](http://cx4a.org/software/popup/popup2.png)\n\n**Popup Cascade Menu**\n\n![](http://cx4a.org/software/popup/popup3.png)\n\nInstallation\n------------\n\nInstall `popup.el` into your `load-path` directory. If you have\n`install-elisp` or `auto-install`, you also be able to install\n`popup.el` like:\n\n    ;; install-elisp\n    (install-elisp \"https://github.com/m2ym/popup-el/raw/master/popup.el\")\n    ;; auto-install\n    (auto-install-from-url \"https://github.com/m2ym/popup-el/raw/master/popup.el\")\n\npopwin is tested under GNU Emacs 22 or later.\n\nPopup Items\n-----------\n\nElements of `popup-list` have to be popup items. A popup item is\nsubstantially a string but it may involve some text-properties. There\nare two ways to make popup items. One is just using strings. Another\nis to use the `popup-make-item` function, which just returns the string\nafter adding text-properties of its keywords. Effective text-properties\nare:\n\n* `value` -- This represents the **real** value of the item. This will\n  be used when returning the value but not the item (or string) from\n  some synchronous functions such as `popup-menu*`.\n* `face` -- The background face of the item. The value of `popup-face`\n  will be overridden.\n* `selection-face` -- The selection face of the item. The value of\n  `popup-selection-face` will be overridden.\n* `document` -- The documentation string or function of the item.\n* `summary` -- The summary string of the item. This will be shown\n  inline with the item.\n* `symbol` -- The symbol character of the item.\n* `sublist` -- The sublist of the item. This is effective only with\n  `popup-cascade-menu`.\n\nAll of properties can be accessed by `popup-item-<property>` utility function.\n\n### Function: `popup-item-propertize`\n\n    popup-item-propertize item &rest properties => item\n\nSame as `propertize` except that this avoids overriding existed value\nwith `nil` property.\n\n### Function: `popup-make-item`\n\n    popup-make-item name &key value popup-face selection-face sublist\n    document symbol summary => item\n\nThe utility function of `popup-item-propertize`.\n\nPopups\n------\n\nThis section describes the basic data structures and operations of\npopups.\n\n### Struct: `popup`\n\nAny instance of `popup` structure has the following fields (some\nunimportant fields are not listed):\n\n* `point`\n* `row` -- The line number.\n* `column`\n* `width` -- Max width of `popup` instance.\n* `height` -- Max height of `popup` instance.\n* `min-height`\n* `current-height`\n* `direction` -- Positive number means forward, negative number means\n  backward.\n* `parent` -- The parent of `popup` instance.\n* `face` -- The background face.\n* `selection-face`\n* `margin-left`\n* `margin-right`\n* `scroll-bar` -- Non-nil means `popup` instance has a scroll bar.\n* `symbol` -- Non-nil means `popup` instance has a space for\n  displaying symbols of item.\n* `cursor` -- The current position of `list`.\n* `scroll-top` -- The offset of scrolling.\n* `list` -- The contents of `popup` instance in a list of items\n  (strings).\n* `original-list` -- Same as `list` except that this is not filtered.\n\nAll of these fields can be accessed by `popup-<field>` function.\n\n### Function: `popup-create`\n\n    popup-create point width height &key min-height max-width around face\n    selection-face scroll-bar margin-left margin-right symbol parent\n    parent-offset => popup\n\nCreate a popup instance at `POINT` with `WIDTH` and `HEIGHT`.\n\n`MIN-HEIGHT` is the minimal height of the popup. The default value is 0.\n\n`MAX-WIDTH` is the maximum width of the popup. The default value is\nnil (no limit). If a floating point, the value refers to the ratio of\nthe window. If an integer, limit is in characters.\n\nIf `AROUND` is non-nil, the popup will be displayed around the point\nbut not at the point.\n\n`FACE` is the background face of the popup. The default value is\n`popup-face`.\n\n`SELECTION-FACE` is the foreground (selection) face of the popup The\ndefault value is `popup-face`.\n\nIf `SCROLL-BAR` is non-nil, the popup will have a scroll bar at the\nright.\n\nIf `MARGIN-LEFT` is non-nil, the popup will have a margin at the left.\n\nIf `MARGIN-RIGHT` is non-nil, the popup will have a margin at the\nright.\n\n`SYMBOL` is a single character which indicates the kind of the item.\n\n`PARENT` is the parent popup instance. If `PARENT` is omitted, the popup\nwill be a root instance.\n\n`PARENT-OFFSET` is a row offset from the parent popup.\n\nHere is an example:\n\n    (setq popup (popup-create (point) 10 10))\n    (popup-set-list popup '(\"Foo\" \"Bar\" \"Baz\"))\n    (popup-draw popup)\n    ;; do something here\n    (popup-delete popup)\n\n### Function: `popup-delete`\n\n    popup-delete popup\n\nDelete the `POPUP`.\n\n### Function: `popup-live-p`\n\n    popup-live-p popup => boolean\n\n### Function: `popup-set-list`\n\n    popup-set-list popup list\n\nSet the contents of the `POPUP`. `LIST` has to be popup items.\n\n### Function: `popup-draw`\n\n    popup-draw popup\n\nDraw the contents of the `POPUP`.\n\n### Function: `popup-hide`\n\n    popup-hide popup\n\nHide the `POPUP`. To show again, call `popup-draw`.\n\n### Function: `popup-hidden-p`\n\n    popup-hidden-p popup\n\nReturn non-nil if the `POPUP` is hidden.\n\n### Function: `popup-select`\n\n    popup-select popup index\n\nSelect the item of `INDEX` of the `POPUP`.\n\n### Function: `popup-selected-item`\n\n    popup-selected-item popup => item\n\nReturn the selected item of the `POPUP`.\n\nReturn non-nil if the `POPUP` is still alive.\n\n### Function: `popup-next`\n\n    popup-next popup\n\nSelect the next item of the `POPUP`.\n\n### Function: `popup-previous`\n\n    popup-previous popup\n\nSelect the next item of the `POPUP`.\n\n### Function: `popup-scroll-down`\n\n    popup-scroll-down popup n\n\nScroll down `N` items of the `POPUP`. This won't wrap.\n\n### Function: `popup-scroll-up`\n\n    popup-scroll-up popup n\n\nScroll up `N` items of the `POPUP`. This won't wrap.\n\n### Function: `popup-isearch`\n\n    popup-isearch popup &key cursor-color keymap callback help-delay\n    => boolean\n\nEnter incremental search event loop of `POPUP`.\n\nTooltips\n--------\n\nA tooltip is an useful visual UI widget for displaying information\nsomething about what cursor points to.\n\n### Function: `popup-tip`\n\n    popup-tip string &key point around width height min-height max-width\n    truncate margin margin-left margin-right scroll-bar parent\n    parent-offset nowait nostrip prompt\n\nShow a tooltip with message `STRING` at `POINT`. This function is\nsynchronized unless `NOWAIT` specified. Almost all arguments are same as\n`popup-create` except for `TRUNCATE`, `NOWAIT`, `NOSTRIP` and `PROMPT`.\n\nIf `TRUNCATE` is non-nil, the tooltip can be truncated.\n\nIf `NOWAIT` is non-nil, this function immediately returns the tooltip\ninstance without entering event loop.\n\nIf `NOSTRIP` is non-nil, `STRING` properties are not stripped.\n\n`PROMPT` is a prompt string used when reading events during the event\nloop.\n\nHere is an example:\n\n    (popup-tip \"Hello, World!\")\n    ;; reach here after the tooltip disappeared\n\nPopup Menus\n-----------\n\nPopup menu is an useful visual UI widget for prompting users to\nselect an item of a list.\n\n### Function: `popup-menu*`\n\n    popup-menu* list &key point around width height margin margin-left\n    margin-right scroll-bar symbol parent parent-offset keymap\n    fallback help-delay nowait prompt isearch isearch-cursor-color\n    isearch-keymap isearch-callback initial-index => selected-value\n\nShow a popup menu of `LIST` at `POINT`. This function returns the value\nof the selected item. Almost all arguments are same as `popup-create`\nexcept for `KEYMAP`, `FALLBACK`, `HELP-DELAY`, `PROMPT`, `ISEARCH`,\n`ISEARCH-CURSOR-COLOR`, `ISEARCH-KEYMAP`, and `ISEARCH-CALLBACK`.\n\nIf `KEYMAP` is provided, it is a keymap which is used when processing\nevents during event loop.\n\nIf `FALLBACK` is provided, it is a function taking two arguments; a key\nand a command. `FALLBACK` is called when no special operation is found\non the key. The default value is `popup-menu-fallback`, which does\nnothing.\n\n`HELP-DELAY` is a delay of displaying helps.\n\nIf `NOWAIT` is non-nil, this function immediately returns the menu\ninstance without entering event loop.\n\n`PROMPT` is a prompt string when reading events during event loop.\n\nIf `ISEARCH` is non-nil, do isearch as soon as displaying the popup\nmenu.\n\n`ISEARCH-CURSOR-COLOR` is a cursor color during isearch. The default\nvalue is `popup-isearch-cursor-color'.\n\n`ISEARCH-KEYMAP` is a keymap which is used when processing events\nduring event loop. The default value is `popup-isearch-keymap`.\n\n`ISEARCH-CALLBACK` is a function taking one argument.  `popup-menu`\ncalls `ISEARCH-CALLBACK`, if specified, after isearch finished or\nisearch canceled. The arguments is whole filtered list of items.\n\nIf `INITIAL-INDEX` is non-nil, this is an initial index value for\n`popup-select`. Only positive integer is valid.\n\nHere is an example:\n\n    (popup-menu* '(\"Foo\" \"Bar\" \"Baz\"))\n    ;; => \"Baz\" if you select Baz\n    (popup-menu* (list (popup-make-item \"Yes\" :value t)\n                       (popup-make-item \"No\" :value nil)))\n    ;; => t if you select Yes\n\n### Function: `popup-cascade-menu`\n\nSame as `popup-menu` except that an element of `LIST` can be also a\nsub-menu if the element is a cons cell formed `(ITEM . SUBLIST)` where\n`ITEM` is an usual item and `SUBLIST` is a list of the sub menu.\n\nHere is an example:\n\n    (popup-cascade-menu '((\"Top1\" \"Sub1\" \"Sub2\") \"Top2\"))\n\n----\n\nCopyright (C) 2011  Tomohiro Matsuyama <<tomo@cx4a.org>>\n" "README.md" nil nil nil nil nil nil)
		       ("popup.el" ";;; popup.el --- Visual Popup User Interface\n\n;; Copyright (C) 2009, 2010, 2011, 2012, 2013  Tomohiro Matsuyama\n\n;; Author: Tomohiro Matsuyama <tomo@cx4a.org>\n;; Keywords: lisp\n;; Version: 0.5.0\n;; Package-Requires: ((cl-lib \"0.3\"))\n\n;; This program is free software; you can redistribute it and/or modify\n;; it under the terms of the GNU General Public License as published by\n;; the Free Software Foundation, either version 3 of the License, or\n;; (at your option) any later version.\n\n;; This program is distributed in the hope that it will be useful,\n;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;; GNU General Public License for more details.\n\n;; You should have received a copy of the GNU General Public License\n;; along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n;;; Commentary:\n\n;; popup.el is a visual popup user interface library for Emacs. This\n;; provides a basic API and common UI widgets such as popup tooltips\n;; and popup menus.\n;; See README.markdown for more information.\n\n;;; Code:\n\n(require 'cl-lib)\n\n(defconst popup-version \"0.5.0\")\n\n\f\n\n;;; Utilities\n\n(defun popup-calculate-max-width (max-width)\n  \"Determines whether the width desired is\ncharacter or window proportion based, And returns the result.\"\n  (cl-typecase max-width\n    (integer max-width)\n    (float (* (ceiling (/ (round (* max-width (window-width))) 10.0)) 10))))\n\n(defvar popup-use-optimized-column-computation t\n  \"Use the optimized column computation routine.\nIf there is a problem, please set it nil.\")\n\n(defmacro popup-aif (test then &rest else)\n  \"Anaphoric if.\"\n  (declare (indent 2))\n  `(let ((it ,test))\n     (if it ,then ,@else)))\n\n(defmacro popup-awhen (test &rest body)\n  \"Anaphoric when.\"\n  (declare (indent 1))\n  `(let ((it ,test))\n     (when it ,@body)))\n\n(defun popup-x-to-string (x)\n  \"Convert any object to string effeciently.\nThis is faster than `prin1-to-string' in many cases.\"\n  (cl-typecase x\n    (string x)\n    (symbol (symbol-name x))\n    (integer (number-to-string x))\n    (float (number-to-string x))\n    (t (format \"%s\" x))))\n\n(defun popup-substring-by-width (string width)\n  \"Return a cons cell of substring and remaining string by\nsplitting with WIDTH.\"\n  ;; Expand tabs into 4 spaces\n  (setq string (replace-regexp-in-string \"\\t\" \"    \" string))\n  (cl-loop with len = (length string)\n           with w = 0\n           for l from 0\n           for c in (append string nil)\n           while (<= (cl-incf w (char-width c)) width)\n           finally return\n           (if (< l len)\n               (cons (substring string 0 l) (substring string l))\n             (list string))))\n\n(defun popup-fill-string (string &optional width max-width justify squeeze)\n  \"Split STRING into fixed width strings and return a cons cell\nlike \\(WIDTH . ROWS). Here, the car WIDTH indicates the actual\nmaxim width of ROWS.\n\nThe argument WIDTH specifies the width of filling each\nparagraph. WIDTH nil means don't perform any justification and\nword wrap. Note that this function doesn't add any padding\ncharacters at the end of each row.\n\nMAX-WIDTH, if WIDTH is nil, specifies the maximum number of\ncolumns.\n\nThe optional fourth argument JUSTIFY specifies which kind of\njustification to do: `full', `left', `right', `center', or\n`none' (equivalent to nil).  A value of t means handle each\nparagraph as specified by its text properties.\n\nSQUEEZE nil means leave whitespaces other than line breaks\nuntouched.\"\n  (if (eq width 0)\n      (error \"Can't fill string with 0 width\"))\n  (if width\n      (setq max-width width))\n  (with-temp-buffer\n    (let ((tab-width 4)\n          (fill-column width)\n          (left-margin 0)\n          (kinsoku-limit 1)\n          indent-tabs-mode\n          row rows)\n      (insert string)\n      (untabify (point-min) (point-max))\n      (if width\n          (fill-region (point-min) (point-max) justify (not squeeze)))\n      (goto-char (point-min))\n      (setq width 0)\n      (while (prog2\n                 (let ((line (buffer-substring\n                              (point) (progn (end-of-line) (point)))))\n                   (if max-width\n                       (while (progn\n                                (setq row (truncate-string-to-width line max-width)\n                                      width (max width (string-width row)))\n                                (push row rows)\n                                (if (not (= (length row) (length line)))\n                                    (setq line (substring line (length row))))))\n                     (setq width (max width (string-width line)))\n                     (push line rows)))\n                 (< (point) (point-max))\n               (beginning-of-line 2)))\n      (cons width (nreverse rows)))))\n\n(defmacro popup-save-buffer-state (&rest body)\n  (declare (indent 0))\n  `(save-excursion\n     (let ((buffer-undo-list t)\n           (inhibit-read-only t)\n           (modified (buffer-modified-p)))\n       (unwind-protect\n           (progn ,@body)\n         (set-buffer-modified-p modified)))))\n\n(defun popup-window-full-width-p (&optional window)\n  \"A portable version of `window-full-width-p'.\"\n  (if (fboundp 'window-full-width-p)\n      (window-full-width-p window)\n    (= (window-width window) (frame-width (window-frame (or window (selected-window)))))))\n\n(defun popup-truncated-partial-width-window-p (&optional window)\n  \"A portable version of `truncated-partial-width-window-p'.\"\n  (unless window\n    (setq window (selected-window)))\n  (unless (popup-window-full-width-p window)\n    (let ((t-p-w-w (buffer-local-value 'truncate-partial-width-windows\n                                       (window-buffer window))))\n      (if (integerp t-p-w-w)\n          (< (window-width window) t-p-w-w)\n        t-p-w-w))))\n\n(defun popup-current-physical-column ()\n  \"Return the current physical column.\"\n  (or (when (and popup-use-optimized-column-computation\n                 (eq (window-hscroll) 0))\n        (let ((current-column (current-column)))\n          (if (or (popup-truncated-partial-width-window-p)\n                  truncate-lines\n                  (< current-column (window-width)))\n              current-column)))\n      (car (posn-col-row (posn-at-point)))))\n\n(defun popup-vertical-motion (column direction)\n  \"A portable version of `vertical-motion'.\"\n  (if (>= emacs-major-version 23)\n      (vertical-motion (cons column direction))\n    (vertical-motion direction)\n    (move-to-column (+ (current-column) column))))\n\n(defun popup-last-line-of-buffer-p ()\n  \"Return non-nil if the cursor is at the last line of the\nbuffer.\"\n  (save-excursion (end-of-line) (/= (forward-line) 0)))\n\n(defun popup-lookup-key-by-event (function event)\n  (or (funcall function (vector event))\n      (if (symbolp event)\n          (popup-aif (get event 'event-symbol-element-mask)\n              (funcall function\n                       (vector (logior (or (get (car it) 'ascii-character)\n                                           0)\n                                       (cadr it))))))))\n\n\f\n\n;;; Core\n\n(defgroup popup nil\n  \"Visual Popup User Interface\"\n  :group 'lisp\n  :prefix \"popup-\")\n\n(defface popup-face\n  '((t (:background \"lightgray\" :foreground \"black\")))\n  \"Face for popup.\"\n  :group 'popup)\n\n(defface popup-summary-face\n  '((t (:inherit popup-face :foreground \"dimgray\")))\n  \"Face for popup summary.\"\n  :group 'popup)\n\n(defface popup-scroll-bar-foreground-face\n  '((t (:background \"black\")))\n  \"Foreground face for scroll-bar.\"\n  :group 'popup)\n\n(defface popup-scroll-bar-background-face\n  '((t (:background \"gray\")))\n  \"Background face for scroll-bar.\"\n  :group 'popup)\n\n(defvar popup-instances nil\n  \"Popup instances.\")\n\n(defvar popup-scroll-bar-foreground-char\n  (propertize \" \" 'face 'popup-scroll-bar-foreground-face)\n  \"Foreground character for scroll-bar.\")\n\n(defvar popup-scroll-bar-background-char\n  (propertize \" \" 'face 'popup-scroll-bar-background-face)\n  \"Background character for scroll-bar.\")\n\n(cl-defstruct popup\n  point row column width height min-height direction overlays keymap\n  parent depth\n  face mouse-face selection-face summary-face\n  margin-left margin-right margin-left-cancel scroll-bar symbol\n  cursor offset scroll-top current-height list newlines\n  pattern original-list)\n\n(defun popup-item-propertize (item &rest properties)\n  \"Same as `propertize' except that this avoids overriding\nexisted value with `nil' property.\"\n  (cl-loop for (k v) on properties by 'cddr\n           if v append (list k v) into props\n           finally return\n           (apply 'propertize\n                  (popup-x-to-string item)\n                  props)))\n\n(defun popup-item-property (item property)\n  \"Same as `get-text-property' except that this returns nil if\nITEM is not string.\"\n  (if (stringp item)\n      (get-text-property 0 property item)))\n\n(cl-defun popup-make-item (name\n                           &key\n                           value\n                           face\n                           mouse-face\n                           selection-face\n                           sublist\n                           document\n                           symbol\n                           summary)\n  \"Utility function to make popup item. See also\n`popup-item-propertize'.\"\n  (popup-item-propertize name\n                         'value value\n                         'popup-face face\n                         'popup-mouse-face mouse-face\n                         'selection-face selection-face\n                         'document document\n                         'symbol symbol\n                         'summary summary\n                         'sublist sublist))\n\n(defsubst popup-item-value (item)               (popup-item-property item 'value))\n(defsubst popup-item-value-or-self (item)       (or (popup-item-value item) item))\n(defsubst popup-item-face (item)                (popup-item-property item 'popup-face))\n(defsubst popup-item-mouse-face (item)          (popup-item-property item 'popup-mouse-face))\n(defsubst popup-item-selection-face (item)      (popup-item-property item 'selection-face))\n(defsubst popup-item-document (item)            (popup-item-property item 'document))\n(defsubst popup-item-summary (item)             (popup-item-property item 'summary))\n(defsubst popup-item-symbol (item)              (popup-item-property item 'symbol))\n(defsubst popup-item-sublist (item)             (popup-item-property item 'sublist))\n\n(defun popup-item-documentation (item)\n  (let ((doc (popup-item-document item)))\n    (if (functionp doc)\n        (setq doc (funcall doc (popup-item-value-or-self item))))\n    doc))\n\n(defun popup-item-show-help-1 (item)\n  (let ((doc (popup-item-documentation item)))\n    (when doc\n      (with-current-buffer (get-buffer-create \" *Popup Help*\")\n        (erase-buffer)\n        (insert doc)\n        (goto-char (point-min))\n        (display-buffer (current-buffer)))\n      t)))\n\n(defun popup-item-show-help-with-event-loop (item)\n  (save-window-excursion\n    (when (popup-item-show-help-1 item)\n      (cl-loop do (clear-this-command-keys)\n               for key = (read-key-sequence-vector nil)\n               do\n               (cl-case (key-binding key)\n                 (scroll-other-window\n                  (scroll-other-window))\n                 (scroll-other-window-down\n                  (scroll-other-window-down nil))\n                 (otherwise\n                  (setq unread-command-events (append key unread-command-events))\n                  (cl-return)))))))\n\n(defun popup-item-show-help (item &optional persist)\n  \"Display the documentation of ITEM with `display-buffer'. If\nPERSIST is nil, the documentation buffer will be closed\nautomatically, meaning interal event loop ensures the buffer to\nbe closed. Otherwise, the buffer will be just displayed as\nusual.\"\n  (when item\n    (if (not persist)\n        (popup-item-show-help-with-event-loop item)\n      (popup-item-show-help-1 item))))\n\n(defun popup-set-list (popup list)\n  (popup-set-filtered-list popup list)\n  (setf (popup-pattern popup) nil)\n  (setf (popup-original-list popup) list))\n\n(defun popup-set-filtered-list (popup list)\n  (let ((offset\n         (if (> (popup-direction popup) 0)\n             0\n           (max (- (popup-height popup) (length list)) 0))))\n    (setf (popup-list popup) list\n          (popup-offset popup) offset)))\n\n(defun popup-selected-item (popup)\n  (nth (popup-cursor popup) (popup-list popup)))\n\n(defun popup-selected-line (popup)\n  (- (popup-cursor popup) (popup-scroll-top popup)))\n\n(defun popup-line-overlay (popup line)\n  (aref (popup-overlays popup) line))\n\n(defun popup-selected-line-overlay (popup)\n  (popup-line-overlay popup (popup-selected-line popup)))\n\n(defun popup-hide-line (popup line)\n  (let ((overlay (popup-line-overlay popup line)))\n    (overlay-put overlay 'display nil)\n    (overlay-put overlay 'after-string nil)))\n\n(defun popup-line-hidden-p (popup line)\n  (let ((overlay (popup-line-overlay popup line)))\n    (and (eq (overlay-get overlay 'display) nil)\n         (eq (overlay-get overlay 'after-string) nil))))\n\n(cl-defun popup-set-line-item (popup\n                               line\n                               &key\n                               item\n                               face\n                               mouse-face\n                               margin-left\n                               margin-right\n                               scroll-bar-char\n                               symbol\n                               summary\n                               summary-face\n                               keymap)\n  (let* ((overlay (popup-line-overlay popup line))\n         (content (popup-create-line-string popup (popup-x-to-string item)\n                                            :margin-left margin-left\n                                            :margin-right margin-right\n                                            :symbol symbol\n                                            :summary summary\n                                            :summary-face summary-face))\n         (start 0)\n         (prefix (overlay-get overlay 'prefix))\n         (postfix (overlay-get overlay 'postfix))\n         end)\n    (put-text-property 0 (length content) 'popup-item item content)\n    (put-text-property 0 (length content) 'keymap keymap content)\n    ;; Overlap face properties\n    (when (get-text-property start 'face content)\n      (setq start (next-single-property-change start 'face content)))\n    (while (and start (setq end (next-single-property-change start 'face content)))\n      (put-text-property start end 'face face content)\n      (setq start (next-single-property-change end 'face content)))\n    (when start\n      (put-text-property start (length content) 'face face content))\n    (when mouse-face\n      (put-text-property 0 (length content) 'mouse-face mouse-face content))\n    (unless (overlay-get overlay 'dangle)\n      (overlay-put overlay 'display (concat prefix (substring content 0 1)))\n      (setq prefix nil\n            content (concat (substring content 1))))\n    (overlay-put overlay\n                 'after-string\n                 (concat prefix\n                         content\n                         scroll-bar-char\n                         postfix))))\n\n(cl-defun popup-create-line-string (popup\n                                    string\n                                    &key\n                                    margin-left\n                                    margin-right\n                                    symbol\n                                    summary\n                                    summary-face)\n  (let* ((popup-width (popup-width popup))\n         (summary-width (string-width summary))\n         (content-width (max\n                         (min popup-width (string-width string))\n                         (- popup-width\n                            (if (> summary-width 0)\n                                (+ summary-width 2)\n                              0))))\n         (string (car (popup-substring-by-width string content-width)))\n         (string-width (string-width string))\n         (spacing (max (- popup-width string-width summary-width)\n                       (if (> popup-width string-width) 1 0)))\n         (truncated-summary\n          (car (popup-substring-by-width\n                summary (max (- popup-width string-width spacing) 0)))))\n    (when summary-face\n      (put-text-property 0 (length truncated-summary)\n                         'face summary-face truncated-summary))\n    (concat margin-left\n            string\n            (make-string spacing ? )\n            truncated-summary\n            symbol\n            margin-right)))\n\n(defun popup-live-p (popup)\n  \"Return non-nil if POPUP is alive.\"\n  (and popup (popup-overlays popup) t))\n\n(defun popup-child-point (popup &optional offset)\n  (overlay-end\n   (popup-line-overlay\n    popup\n    (or offset\n        (popup-selected-line popup)))))\n\n(defun popup-calculate-direction (height row)\n  \"Return a proper direction when displaying a popup on this\nwindow. HEIGHT is the a height of the popup, and ROW is a line\nnumber at the point.\"\n  (let* ((remaining-rows (- (max 1 (- (window-height)\n                                      (if mode-line-format 1 0)\n                                      (if header-line-format 1 0)))\n                            (count-lines (window-start) (point))))\n         (enough-space-above (> row height))\n         (enough-space-below (<= height remaining-rows)))\n    (if (and enough-space-above\n             (not enough-space-below))\n        -1\n      1)))\n\n(cl-defun popup-create (point\n                        width\n                        height\n                        &key\n                        min-height\n                        max-width\n                        around\n                        (face 'popup-face)\n                        mouse-face\n                        (selection-face face)\n                        (summary-face 'popup-summary-face)\n                        scroll-bar\n                        margin-left\n                        margin-right\n                        symbol\n                        parent\n                        parent-offset\n                        keymap)\n  \"Create a popup instance at POINT with WIDTH and HEIGHT.\n\nMIN-HEIGHT is a minimal height of the popup. The default value is\n0.\n\nMAX-WIDTH is the maximum width of the popup. The default value is\nnil (no limit). If a floating point, the value refers to the ratio of\nthe window. If an integer, limit is in characters.\n\nIf AROUND is non-nil, the popup will be displayed around the\npoint but not at the point.\n\nFACE is a background face of the popup. The default value is POPUP-FACE.\n\nSELECTION-FACE is a foreground (selection) face of the popup The\ndefault value is POPUP-FACE.\n\nIf SCROLL-BAR is non-nil, the popup will have a scroll bar at the\nright.\n\nIf MARGIN-LEFT is non-nil, the popup will have a margin at the\nleft.\n\nIf MARGIN-RIGHT is non-nil, the popup will have a margin at the\nright.\n\nSYMBOL is a single character which indicates a kind of the item.\n\nPARENT is a parent popup instance. If PARENT is omitted, the\npopup will be a root instance.\n\nPARENT-OFFSET is a row offset from the parent popup.\n\nKEYMAP is a keymap that will be put on the popup contents.\"\n  (or margin-left (setq margin-left 0))\n  (or margin-right (setq margin-right 0))\n  (unless point\n    (setq point\n          (if parent (popup-child-point parent parent-offset) (point))))\n  (when max-width\n    (setq width (min width (popup-calculate-max-width max-width))))\n  (save-excursion\n    (goto-char point)\n    (let* ((row (line-number-at-pos))\n           (column (popup-current-physical-column))\n           (overlays (make-vector height nil))\n           (popup-width (+ width\n                           (if scroll-bar 1 0)\n                           margin-left\n                           margin-right\n                           (if symbol 2 0)))\n           margin-left-cancel\n           (window (selected-window))\n           (window-start (window-start))\n           (window-hscroll (window-hscroll))\n           (window-width (window-width))\n           (right (+ column popup-width))\n           (overflow (and (> right window-width)\n                          (>= right popup-width)))\n           (foldable (and (null parent)\n                          (>= column popup-width)))\n           (direction (or\n                       ;; Currently the direction of cascade popup won't be changed\n                       (and parent (popup-direction parent))\n\n                       ;; Calculate direction\n                       (popup-calculate-direction height row)))\n           (depth (if parent (1+ (popup-depth parent)) 0))\n           (newlines (max 0 (+ (- height (count-lines point (point-max))) (if around 1 0))))\n           current-column)\n      ;; Case: no newlines at the end of the buffer\n      (when (> newlines 0)\n        (popup-save-buffer-state\n          (goto-char (point-max))\n          (insert (make-string newlines ?\\n))))\n\n      ;; Case: the popup overflows\n      (if overflow\n          (if foldable\n              (progn\n                (cl-decf column (- popup-width margin-left margin-right))\n                (unless around (move-to-column column)))\n            (when (not truncate-lines)\n              ;; Truncate.\n              (let ((d (1+ (- popup-width (- window-width column)))))\n                (cl-decf popup-width d)\n                (cl-decf width d)))\n            (cl-decf column margin-left))\n        (cl-decf column margin-left))\n\n      ;; Case: no space at the left\n      (when (and (null parent)\n                 (< column 0))\n        ;; Cancel margin left\n        (setq column 0)\n        (cl-decf popup-width margin-left)\n        (setq margin-left-cancel t))\n\n      (dotimes (i height)\n        (let (overlay begin w (dangle t) (prefix \"\") (postfix \"\"))\n          (when around\n            (popup-vertical-motion column direction))\n          (setq around t\n                current-column (popup-current-physical-column))\n\n          (when (> current-column column)\n            (backward-char)\n            (setq current-column (popup-current-physical-column)))\n          (when (< current-column column)\n            ;; Extend short buffer lines by popup prefix (line of spaces)\n            (setq prefix (make-string\n                          (+ (if (= current-column 0)\n                                 (- window-hscroll (current-column))\n                               0)\n                             (- column current-column))\n                          ? )))\n\n          (setq begin (point))\n          (setq w (+ popup-width (length prefix)))\n          (while (and (not (eolp)) (> w 0))\n            (setq dangle nil)\n            (cl-decf w (char-width (char-after)))\n            (forward-char))\n          (if (< w 0)\n              (setq postfix (make-string (- w) ? )))\n\n          (setq overlay (make-overlay begin (point)))\n          (overlay-put overlay 'window window)\n          (overlay-put overlay 'dangle dangle)\n          (overlay-put overlay 'prefix prefix)\n          (overlay-put overlay 'postfix postfix)\n          (overlay-put overlay 'width width)\n          (aset overlays\n                (if (> direction 0) i (- height i 1))\n                overlay)))\n      (cl-loop for p from (- 10000 (* depth 1000))\n               for overlay in (nreverse (append overlays nil))\n               do (overlay-put overlay 'priority p))\n      (let ((it (make-popup :point point\n                            :row row\n                            :column column\n                            :width width\n                            :height height\n                            :min-height min-height\n                            :direction direction\n                            :parent parent\n                            :depth depth\n                            :face face\n                            :mouse-face mouse-face\n                            :selection-face selection-face\n                            :summary-face summary-face\n                            :margin-left margin-left\n                            :margin-right margin-right\n                            :margin-left-cancel margin-left-cancel\n                            :scroll-bar scroll-bar\n                            :symbol symbol\n                            :cursor 0\n                            :offset 0\n                            :scroll-top 0\n                            :current-height 0\n                            :list nil\n                            :newlines newlines\n                            :overlays overlays\n                            :keymap keymap)))\n        (push it popup-instances)\n        it))))\n\n(defun popup-delete (popup)\n  \"Delete POPUP instance.\"\n  (when (popup-live-p popup)\n    (popup-hide popup)\n    (mapc 'delete-overlay (popup-overlays popup))\n    (setf (popup-overlays popup) nil)\n    (setq popup-instances (delq popup popup-instances))\n    ;; Restore newlines state\n    (let ((newlines (popup-newlines popup)))\n      (when (> newlines 0)\n        (popup-save-buffer-state\n          (goto-char (point-max))\n          (dotimes (i newlines)\n            (if (and (char-before)\n                     (= (char-before) ?\\n))\n                (delete-char -1)))))))\n  nil)\n\n(defun popup-draw (popup)\n  \"Draw POPUP.\"\n  (cl-loop with height = (popup-height popup)\n           with min-height = (popup-min-height popup)\n           with popup-face = (popup-face popup)\n           with mouse-face = (popup-mouse-face popup)\n           with selection-face = (popup-selection-face popup)\n           with summary-face-0 = (popup-summary-face popup)\n           with list = (popup-list popup)\n           with length = (length list)\n           with thum-size = (max (/ (* height height) (max length 1)) 1)\n           with page-size = (/ (+ 0.0 (max length 1)) height)\n           with scroll-bar = (popup-scroll-bar popup)\n           with margin-left = (make-string (if (popup-margin-left-cancel popup) 0 (popup-margin-left popup)) ? )\n           with margin-right = (make-string (popup-margin-right popup) ? )\n           with symbol = (popup-symbol popup)\n           with cursor = (popup-cursor popup)\n           with scroll-top = (popup-scroll-top popup)\n           with offset = (popup-offset popup)\n           with keymap = (popup-keymap popup)\n           for o from offset\n           for i from scroll-top\n           while (< o height)\n           for item in (nthcdr scroll-top list)\n           for page-index = (* thum-size (/ o thum-size))\n           for face = (if (= i cursor)\n                          (or (popup-item-selection-face item) selection-face)\n                        (or (popup-item-face item) popup-face))\n           for summary-face = (unless (= i cursor) summary-face-0)\n           for empty-char = (propertize \" \" 'face face)\n           for scroll-bar-char = (if scroll-bar\n                                     (cond\n                                      ((and (not (eq scroll-bar :always))\n                                            (<= page-size 1))\n                                       empty-char)\n                                      ((and (> page-size 1)\n                                            (>= cursor (* page-index page-size))\n                                            (< cursor (* (+ page-index thum-size) page-size)))\n                                       popup-scroll-bar-foreground-char)\n                                      (t\n                                       popup-scroll-bar-background-char))\n                                   \"\")\n           for sym = (if symbol\n                         (concat \" \" (or (popup-item-symbol item) \" \"))\n                       \"\")\n           for summary = (or (popup-item-summary item) \"\")\n\n           do\n           ;; Show line and set item to the line\n           (popup-set-line-item popup o\n                                :item item\n                                :face face\n                                :mouse-face mouse-face\n                                :margin-left margin-left\n                                :margin-right margin-right\n                                :scroll-bar-char scroll-bar-char\n                                :symbol sym\n                                :summary summary\n                                :summary-face summary-face\n                                :keymap keymap)\n\n           finally\n           ;; Remember current height\n           (setf (popup-current-height popup) (- o offset))\n\n           ;; Hide remaining lines\n           (let ((scroll-bar-char (if scroll-bar (propertize \" \" 'face popup-face) \"\"))\n                 (symbol (if symbol \" \" \"\")))\n             (if (> (popup-direction popup) 0)\n                 (progn\n                   (when min-height\n                     (while (< o min-height)\n                       (popup-set-line-item popup o\n                                            :item \"\"\n                                            :face popup-face\n                                            :margin-left margin-left\n                                            :margin-right margin-right\n                                            :scroll-bar-char scroll-bar-char\n                                            :symbol symbol\n                                            :summary \"\")\n                       (cl-incf o)))\n                   (while (< o height)\n                     (popup-hide-line popup o)\n                     (cl-incf o)))\n               (cl-loop with h = (if min-height (- height min-height) offset)\n                        for o from 0 below offset\n                        if (< o h)\n                        do (popup-hide-line popup o)\n                        if (>= o h)\n                        do (popup-set-line-item popup o\n                                                :item \"\"\n                                                :face popup-face\n                                                :margin-left margin-left\n                                                :margin-right margin-right\n                                                :scroll-bar-char scroll-bar-char\n                                                :symbol symbol\n                                                :summary \"\"))))))\n\n(defun popup-hide (popup)\n  \"Hide POPUP.\"\n  (dotimes (i (popup-height popup))\n    (popup-hide-line popup i)))\n\n(defun popup-hidden-p (popup)\n  \"Return non-nil if POPUP is hidden.\"\n  (let ((hidden t))\n    (when (popup-live-p popup)\n      (dotimes (i (popup-height popup))\n        (unless (popup-line-hidden-p popup i)\n          (setq hidden nil))))\n    hidden))\n\n(defun popup-jump (popup cursor)\n  \"Jump to a position specified by CURSOR of POPUP and draw.\"\n  (let ((scroll-top (popup-scroll-top popup)))\n    ;; Do not change page as much as possible.\n    (unless (and (<= scroll-top cursor)\n                 (< cursor (+ scroll-top (popup-height popup))))\n      (setf (popup-scroll-top popup) cursor))\n    (setf (popup-cursor popup) cursor)\n    (popup-draw popup)))\n\n(defun popup-select (popup i)\n  \"Select the item at I of POPUP and draw.\"\n  (setq i (+ i (popup-offset popup)))\n  (when (and (<= 0 i) (< i (popup-height popup)))\n    (setf (popup-cursor popup) i)\n    (popup-draw popup)\n    t))\n\n(defun popup-next (popup)\n  \"Select the next item of POPUP and draw.\"\n  (let ((height (popup-height popup))\n        (cursor (1+ (popup-cursor popup)))\n        (scroll-top (popup-scroll-top popup))\n        (length (length (popup-list popup))))\n    (cond\n     ((>= cursor length)\n      ;; Back to first page\n      (setq cursor 0\n            scroll-top 0))\n     ((= cursor (+ scroll-top height))\n      ;; Go to next page\n      (setq scroll-top (min (1+ scroll-top) (max (- length height) 0)))))\n    (setf (popup-cursor popup) cursor\n          (popup-scroll-top popup) scroll-top)\n    (popup-draw popup)))\n\n(defun popup-previous (popup)\n  \"Select the previous item of POPUP and draw.\"\n  (let ((height (popup-height popup))\n        (cursor (1- (popup-cursor popup)))\n        (scroll-top (popup-scroll-top popup))\n        (length (length (popup-list popup))))\n    (cond\n     ((< cursor 0)\n      ;; Go to last page\n      (setq cursor (1- length)\n            scroll-top (max (- length height) 0)))\n     ((= cursor (1- scroll-top))\n      ;; Go to previous page\n      (cl-decf scroll-top)))\n    (setf (popup-cursor popup) cursor\n          (popup-scroll-top popup) scroll-top)\n    (popup-draw popup)))\n\n(defun popup-page-next (popup)\n  \"Select next item of POPUP per `popup-height' range.\nPages down through POPUP.\"\n  (dotimes (counter (1- (popup-height popup)))\n    (popup-next popup)))\n\n(defun popup-page-previous (popup)\n  \"Select previous item of POPUP per `popup-height' range.\nPages up through POPUP.\"\n  (dotimes (counter (1- (popup-height popup)))\n    (popup-previous popup)))\n\n(defun popup-scroll-down (popup &optional n)\n  \"Scroll down N of POPUP and draw.\"\n  (let ((scroll-top (min (+ (popup-scroll-top popup) (or n 1))\n                         (- (length (popup-list popup)) (popup-height popup)))))\n    (setf (popup-cursor popup) scroll-top\n          (popup-scroll-top popup) scroll-top)\n    (popup-draw popup)))\n\n(defun popup-scroll-up (popup &optional n)\n  \"Scroll up N of POPUP and draw.\"\n  (let ((scroll-top (max (- (popup-scroll-top popup) (or n 1))\n                         0)))\n    (setf (popup-cursor popup) scroll-top\n          (popup-scroll-top popup) scroll-top)\n    (popup-draw popup)))\n\n\f\n\n;;; Popup Incremental Search\n\n(defface popup-isearch-match\n  '((t (:background \"sky blue\")))\n  \"Popup isearch match face.\"\n  :group 'popup)\n\n(defvar popup-isearch-cursor-color \"blue\")\n\n(defvar popup-isearch-keymap\n  (let ((map (make-sparse-keymap)))\n    ;(define-key map \"\\r\"        'popup-isearch-done)\n    (define-key map \"\\C-g\"      'popup-isearch-cancel)\n    (define-key map \"\\C-b\"      'popup-isearch-close)\n    (define-key map [left]      'popup-isearch-close)\n    (define-key map \"\\C-h\"      'popup-isearch-delete)\n    (define-key map (kbd \"DEL\") 'popup-isearch-delete)\n    map))\n\n(defvar popup-menu-show-quick-help-function 'popup-menu-show-quick-help\n  \"Function used for showing quick help by `popup-menu*'.\")\n\n(defsubst popup-isearch-char-p (char)\n  (and (integerp char)\n       (<= 32 char)\n       (<= char 126)))\n\n(defun popup-isearch-filter-list (pattern list)\n  (cl-loop with regexp = (regexp-quote pattern)\n           for item in list\n           do\n           (unless (stringp item)\n             (setq item (popup-item-propertize (popup-x-to-string item)\n                                               'value item)))\n           if (string-match regexp item)\n           collect\n           (let ((beg (match-beginning 0))\n                 (end (match-end 0)))\n             (alter-text-property 0 (length item) 'face\n                                  (lambda (prop)\n                                    (unless (eq prop 'popup-isearch-match)\n                                      prop))\n                                  item)\n             (put-text-property beg end\n                                'face 'popup-isearch-match\n                                item)\n             item)))\n\n(defun popup-isearch-prompt (popup pattern)\n  (format \"Pattern: %s\" (if (= (length (popup-list popup)) 0)\n                            (propertize pattern 'face 'isearch-fail)\n                          pattern)))\n\n(defun popup-isearch-update (popup pattern &optional callback)\n  (setf (popup-cursor popup) 0\n        (popup-scroll-top popup) 0\n        (popup-pattern popup) pattern)\n  (let ((list (popup-isearch-filter-list pattern (popup-original-list popup))))\n    (popup-set-filtered-list popup list)\n    (if callback\n        (funcall callback list)))\n  (popup-draw popup))\n\n(cl-defun popup-isearch (popup\n                         &key\n                         (cursor-color popup-isearch-cursor-color)\n                         (keymap popup-isearch-keymap)\n                         callback\n                         help-delay)\n  \"Start isearch on POPUP. This function is synchronized, meaning\nevent loop waits for quiting of isearch.\n\nCURSOR-COLOR is a cursor color during isearch. The default value\nis `popup-isearch-cursor-color'.\n\nKEYMAP is a keymap which is used when processing events during\nevent loop. The default value is `popup-isearch-keymap'.\n\nCALLBACK is a function taking one argument. `popup-isearch' calls\nCALLBACK, if specified, after isearch finished or isearch\ncanceled. The arguments is whole filtered list of items.\n\nHELP-DELAY is a delay of displaying helps.\"\n  (let ((list (popup-original-list popup))\n        (pattern (or (popup-pattern popup) \"\"))\n        (old-cursor-color (frame-parameter (selected-frame) 'cursor-color))\n        prompt key binding)\n    (unwind-protect\n        (cl-block nil\n          (if cursor-color\n              (set-cursor-color cursor-color))\n          (while t\n            (setq prompt (popup-isearch-prompt popup pattern))\n            (setq key (popup-menu-read-key-sequence keymap prompt help-delay))\n            (if (null key)\n                (unless (funcall popup-menu-show-quick-help-function popup nil :prompt prompt)\n                  (clear-this-command-keys)\n                  (push (read-event prompt) unread-command-events))\n              (setq binding (lookup-key keymap key))\n              (cond\n               ((and (stringp key)\n                     (popup-isearch-char-p (aref key 0)))\n                (setq pattern (concat pattern key)))\n               ((eq binding 'popup-isearch-done)\n                (cl-return nil))\n               ((eq binding 'popup-isearch-cancel)\n                (popup-isearch-update popup \"\" callback)\n                (cl-return t))\n               ((eq binding 'popup-isearch-close)\n                (popup-isearch-update popup \"\" callback)\n                (setq unread-command-events\n                      (append (listify-key-sequence key) unread-command-events))\n                (cl-return nil))\n               ((eq binding 'popup-isearch-delete)\n                (if (> (length pattern) 0)\n                    (setq pattern (substring pattern 0 (1- (length pattern))))))\n               (t\n                (setq unread-command-events\n                      (append (listify-key-sequence key) unread-command-events))\n                (cl-return nil)))\n              (popup-isearch-update popup pattern callback))))\n      (if old-cursor-color\n          (set-cursor-color old-cursor-color)))))\n\n\f\n\n;;; Popup Tip\n\n(defface popup-tip-face\n  '((t (:background \"khaki1\" :foreground \"black\")))\n  \"Face for popup tip.\"\n  :group 'popup)\n\n(defvar popup-tip-max-width 80)\n\n(cl-defun popup-tip (string\n                     &key\n                     point\n                     (around t)\n                     width\n                     (height 15)\n                     min-height\n                     max-width\n                     truncate\n                     margin\n                     margin-left\n                     margin-right\n                     scroll-bar\n                     parent\n                     parent-offset\n                     nowait\n                     nostrip\n                     prompt\n                     &aux tip lines)\n  \"Show a tooltip of STRING at POINT. This function is\nsynchronized unless NOWAIT specified. Almost arguments are same\nas `popup-create' except for TRUNCATE, NOWAIT, and PROMPT.\n\nIf TRUNCATE is non-nil, the tooltip can be truncated.\n\nIf NOWAIT is non-nil, this function immediately returns the\ntooltip instance without entering event loop.\n\nIf `NOSTRIP` is non-nil, `STRING` properties are not stripped.\n\nPROMPT is a prompt string when reading events during event loop.\"\n  (if (bufferp string)\n      (setq string (with-current-buffer string (buffer-string))))\n\n  (unless nostrip\n    ;; TODO strip text (mainly face) properties\n    (setq string (substring-no-properties string)))\n\n  (and (eq margin t) (setq margin 1))\n  (or margin-left (setq margin-left margin))\n  (or margin-right (setq margin-right margin))\n\n  (let ((it (popup-fill-string string width popup-tip-max-width)))\n    (setq width (car it)\n          lines (cdr it)))\n\n  (setq tip (popup-create point width height\n                          :min-height min-height\n                          :max-width max-width\n                          :around around\n                          :margin-left margin-left\n                          :margin-right margin-right\n                          :scroll-bar scroll-bar\n                          :face 'popup-tip-face\n                          :parent parent\n                          :parent-offset parent-offset))\n\n  (unwind-protect\n      (when (> (popup-width tip) 0)                   ; not to be corrupted\n        (when (and (not (eq width (popup-width tip))) ; truncated\n                   (not truncate))\n          ;; Refill once again to lines be fitted to popup width\n          (setq width (popup-width tip))\n          (setq lines (cdr (popup-fill-string string width width))))\n\n        (popup-set-list tip lines)\n        (popup-draw tip)\n        (if nowait\n            tip\n          (clear-this-command-keys)\n          (push (read-event prompt) unread-command-events)\n          t))\n    (unless nowait\n      (popup-delete tip))))\n\n\f\n\n;;; Popup Menu\n\n(defface popup-menu-face\n  '((t (:inherit popup-face)))\n  \"Face for popup menu.\"\n  :group 'popup)\n\n(defface popup-menu-mouse-face\n  '((t (:background \"blue\" :foreground \"white\")))\n  \"Face for popup menu.\"\n  :group 'popup)\n\n(defface popup-menu-selection-face\n  '((t (:background \"steelblue\" :foreground \"white\")))\n  \"Face for popup menu selection.\"\n  :group 'popup)\n\n(defface popup-menu-summary-face\n  '((t (:inherit popup-summary-face)))\n  \"Face for popup summary.\"\n  :group 'popup)\n\n(defvar popup-menu-show-tip-function 'popup-tip\n  \"Function used for showing tooltip by `popup-menu-show-quick-help'.\")\n\n(defun popup-menu-show-help (menu &optional persist item)\n  (popup-item-show-help (or item (popup-selected-item menu)) persist))\n\n(defun popup-menu-documentation (menu &optional item)\n  (popup-item-documentation (or item (popup-selected-item menu))))\n\n(defun popup-menu-show-quick-help (menu &optional item &rest args)\n  (let* ((point (plist-get args :point))\n         (height (or (plist-get args :height) (popup-height menu)))\n         (min-height (min height (popup-current-height menu)))\n         (around nil)\n         (parent-offset (popup-offset menu))\n         (doc (popup-menu-documentation menu item)))\n    (when (stringp doc)\n      (if (popup-hidden-p menu)\n          (setq around t\n                menu nil\n                parent-offset nil)\n        (setq point nil))\n      (let ((popup-use-optimized-column-computation nil)) ; To avoid wrong positioning\n        (apply popup-menu-show-tip-function\n               doc\n               :point point\n               :height height\n               :min-height min-height\n               :around around\n               :parent menu\n               :parent-offset parent-offset\n               args)))))\n\n(defun popup-menu-item-of-mouse-event (event)\n  (when (and (consp event)\n             (memq (cl-first event) '(mouse-1 mouse-2 mouse-3 mouse-4 mouse-5)))\n    (let* ((position (cl-second event))\n           (object (elt position 4)))\n      (when (consp object)\n        (get-text-property (cdr object) 'popup-item (car object))))))\n\n(defun popup-menu-read-key-sequence (keymap &optional prompt timeout)\n  (catch 'timeout\n    (let ((timer (and timeout\n                      (run-with-timer timeout nil\n                                      (lambda ()\n                                        (if (zerop (length (this-command-keys)))\n                                            (throw 'timeout nil))))))\n          (old-global-map (current-global-map))\n          (temp-global-map (make-sparse-keymap))\n          (overriding-terminal-local-map (make-sparse-keymap)))\n      (substitute-key-definition 'keyboard-quit 'keyboard-quit\n                                 temp-global-map old-global-map)\n      (define-key temp-global-map [menu-bar] (lookup-key old-global-map [menu-bar]))\n      (define-key temp-global-map [tool-bar] (lookup-key old-global-map [tool-bar]))\n      (set-keymap-parent overriding-terminal-local-map keymap)\n      (if (current-local-map)\n          (define-key overriding-terminal-local-map [menu-bar]\n            (lookup-key (current-local-map) [menu-bar])))\n      (unwind-protect\n          (progn\n            (use-global-map temp-global-map)\n            (clear-this-command-keys)\n            (with-temp-message prompt\n              (read-key-sequence nil)))\n        (use-global-map old-global-map)\n        (if timer (cancel-timer timer))))))\n\n(defun popup-menu-fallback (event default))\n\n(cl-defun popup-menu-event-loop (menu\n                                 keymap\n                                 fallback\n                                 &key\n                                 prompt\n                                 help-delay\n                                 isearch\n                                 isearch-cursor-color\n                                 isearch-keymap\n                                 isearch-callback\n                                 &aux key binding)\n  (cl-block nil\n    (while (popup-live-p menu)\n      (and isearch\n           (popup-isearch menu\n                          :cursor-color isearch-cursor-color\n                          :keymap isearch-keymap\n                          :callback isearch-callback\n                          :help-delay help-delay)\n           (keyboard-quit))\n      (setq key (popup-menu-read-key-sequence keymap prompt help-delay))\n      (setq binding (and key (lookup-key keymap key)))\n      (cond\n       ((or (null key) (zerop (length key)))\n        (unless (funcall popup-menu-show-quick-help-function menu nil :prompt prompt)\n          (clear-this-command-keys)\n          (push (read-event prompt) unread-command-events)))\n       ((eq (lookup-key (current-global-map) key) 'keyboard-quit)\n        (keyboard-quit)\n        (cl-return))\n       ((eq binding 'popup-close)\n        (if (popup-parent menu)\n            (cl-return)))\n       ((memq binding '(popup-select popup-open))\n        (let* ((item (or (popup-menu-item-of-mouse-event (elt key 0))\n                         (popup-selected-item menu)))\n               (index (cl-position item (popup-list menu)))\n               (sublist (popup-item-sublist item)))\n          (unless index (cl-return))\n          (if sublist\n              (popup-aif (let (popup-use-optimized-column-computation)\n                           (popup-cascade-menu sublist\n                                               :around nil\n                                               :margin-left (popup-margin-left menu)\n                                               :margin-right (popup-margin-right menu)\n                                               :scroll-bar (popup-scroll-bar menu)\n                                               :parent menu\n                                               :parent-offset index\n                                               :help-delay help-delay\n                                               :isearch isearch\n                                               :isearch-cursor-color isearch-cursor-color\n                                               :isearch-keymap isearch-keymap\n                                               :isearch-callback isearch-callback))\n                  (and it (cl-return it)))\n            (if (eq binding 'popup-select)\n                (cl-return (popup-item-value-or-self item))))))\n       ((eq binding 'popup-next)\n        (popup-next menu))\n       ((eq binding 'popup-previous)\n        (popup-previous menu))\n       ((eq binding 'popup-page-next)\n        (popup-page-next menu))\n       ((eq binding 'popup-page-previous)\n        (popup-page-previous menu))\n       ((eq binding 'popup-help)\n        (popup-menu-show-help menu))\n       ((eq binding 'popup-isearch)\n        (popup-isearch menu\n                       :cursor-color isearch-cursor-color\n                       :keymap isearch-keymap\n                       :callback isearch-callback\n                       :help-delay help-delay))\n       ((commandp binding)\n        (call-interactively binding))\n       (t\n        (funcall fallback key (key-binding key)))))))\n\n(defun popup-preferred-width (list)\n  \"Return the preferred width to show LIST beautifully.\"\n  (cl-loop with tab-width = 4\n           for item in list\n           for summary = (popup-item-summary item)\n           maximize (string-width (popup-x-to-string item)) into width\n           if (stringp summary)\n           maximize (+ (string-width summary) 2) into summary-width\n           finally return\n           (let ((total (+ (or width 0) (or summary-width 0))))\n             (* (ceiling (/ total 10.0)) 10))))\n\n(defvar popup-menu-keymap\n  (let ((map (make-sparse-keymap)))\n    (define-key map \"\\r\"        'popup-select)\n    (define-key map \"\\C-f\"      'popup-open)\n    (define-key map [right]     'popup-open)\n    (define-key map \"\\C-b\"      'popup-close)\n    (define-key map [left]      'popup-close)\n\n    (define-key map \"\\C-n\"      'popup-next)\n    (define-key map [down]      'popup-next)\n    (define-key map \"\\C-p\"      'popup-previous)\n    (define-key map [up]        'popup-previous)\n\n    (define-key map [next]      'popup-page-next)\n    (define-key map [prior]     'popup-page-previous)\n\n    (define-key map [f1]        'popup-help)\n    (define-key map (kbd \"\\C-?\") 'popup-help)\n\n    (define-key map \"\\C-s\"      'popup-isearch)\n\n    (define-key map [mouse-1]   'popup-select)\n    (define-key map [mouse-4]   'popup-previous)\n    (define-key map [mouse-5]   'popup-next)\n    map))\n\n(cl-defun popup-menu* (list\n                       &key\n                       point\n                       (around t)\n                       (width (popup-preferred-width list))\n                       (height 15)\n                       max-width\n                       margin\n                       margin-left\n                       margin-right\n                       scroll-bar\n                       symbol\n                       parent\n                       parent-offset\n                       cursor\n                       (keymap popup-menu-keymap)\n                       (fallback 'popup-menu-fallback)\n                       help-delay\n                       nowait\n                       prompt\n                       isearch\n                       (isearch-cursor-color popup-isearch-cursor-color)\n                       (isearch-keymap popup-isearch-keymap)\n                       isearch-callback\n                       initial-index\n                       &aux menu event)\n  \"Show a popup menu of LIST at POINT. This function returns a\nvalue of the selected item. Almost arguments are same as\n`popup-create' except for KEYMAP, FALLBACK, HELP-DELAY, PROMPT,\nISEARCH, ISEARCH-CURSOR-COLOR, ISEARCH-KEYMAP, and\nISEARCH-CALLBACK.\n\nIf KEYMAP is a keymap which is used when processing events during\nevent loop.\n\nIf FALLBACK is a function taking two arguments; a key and a\ncommand. FALLBACK is called when no special operation is found on\nthe key. The default value is `popup-menu-fallback', which does\nnothing.\n\nHELP-DELAY is a delay of displaying helps.\n\nIf NOWAIT is non-nil, this function immediately returns the menu\ninstance without entering event loop.\n\nPROMPT is a prompt string when reading events during event loop.\n\nIf ISEARCH is non-nil, do isearch as soon as displaying the popup\nmenu.\n\nISEARCH-CURSOR-COLOR is a cursor color during isearch. The\ndefault value is `popup-isearch-cursor-color'.\n\nISEARCH-KEYMAP is a keymap which is used when processing events\nduring event loop. The default value is `popup-isearch-keymap'.\n\nISEARCH-CALLBACK is a function taking one argument.  `popup-menu'\ncalls ISEARCH-CALLBACK, if specified, after isearch finished or\nisearch canceled. The arguments is whole filtered list of items.\n\nIf `INITIAL-INDEX' is non-nil, this is an initial index value for\n`popup-select'. Only positive integer is valid.\"\n  (and (eq margin t) (setq margin 1))\n  (or margin-left (setq margin-left margin))\n  (or margin-right (setq margin-right margin))\n  (if (and scroll-bar\n           (integerp margin-right)\n           (> margin-right 0))\n      ;; Make scroll-bar space as margin-right\n      (cl-decf margin-right))\n  (setq menu (popup-create point width height\n                           :max-width max-width\n                           :around around\n                           :face 'popup-menu-face\n                           :mouse-face 'popup-menu-mouse-face\n                           :selection-face 'popup-menu-selection-face\n                           :summary-face 'popup-menu-summary-face\n                           :margin-left margin-left\n                           :margin-right margin-right\n                           :scroll-bar scroll-bar\n                           :symbol symbol\n                           :parent parent\n                           :parent-offset parent-offset))\n  (unwind-protect\n      (progn\n        (popup-set-list menu list)\n        (if cursor\n            (popup-jump menu cursor)\n          (popup-draw menu))\n        (when initial-index\n          (popup-select menu\n                        (min (- (length list) 1) initial-index)))\n        (if nowait\n            menu\n          (popup-menu-event-loop menu keymap fallback\n                                 :prompt prompt\n                                 :help-delay help-delay\n                                 :isearch isearch\n                                 :isearch-cursor-color isearch-cursor-color\n                                 :isearch-keymap isearch-keymap\n                                 :isearch-callback isearch-callback)))\n    (unless nowait\n      (popup-delete menu))))\n\n(defun popup-cascade-menu (list &rest args)\n  \"Same as `popup-menu' except that an element of LIST can be\nalso a sub-menu if the element is a cons cell formed (ITEM\n. SUBLIST) where ITEM is an usual item and SUBLIST is a list of\nthe sub menu.\"\n  (apply 'popup-menu*\n         (mapcar (lambda (item)\n                   (if (consp item)\n                       (popup-make-item (car item)\n                                        :sublist (cdr item)\n                                        :symbol \">\")\n                     item))\n                 list)\n         :symbol t\n         args))\n\n(provide 'popup)\n;;; popup.el ends here\n" "popup.el" nil nil nil nil nil nil)))


;;; Snippet definitions:
;;;
(yas-define-snippets 'popup-el
		     '(("popup-interactive-test.el" "(require 'popup)\n\n(defmacro test (explain &rest body)\n  (declare (indent 1))\n  `(let ((buf \"*buf*\")\n         (window-config (current-window-configuration)))\n     (unwind-protect\n         (progn\n           (delete-other-windows)\n           (switch-to-buffer buf)\n           (erase-buffer)\n           (insert \" \")\n           (let ((success (progn ,@body)))\n             (unless success\n               (error \"failed: %s\" ,explain))))\n       (when popup\n         (popup-delete popup)\n         (setq popup nil))\n       (kill-buffer buf)\n       (set-window-configuration window-config))))\n\n(defmacro ui-test (prompt &rest body)\n  (declare (indent 1))\n  `(test ,prompt ,@body (yes-or-no-p ,prompt)))\n\n(defun input (key)\n  (push key unread-command-events))\n\n(defvar popup nil)\n\n(test \"popup-create\"\n  (setq popup (popup-create (point) 10 10)))\n\n(test \"popup-delete\"\n  (setq popup (popup-create (point) 10 10))\n  (popup-delete popup)\n  (not (popup-live-p popup)))\n\n(ui-test \"popup?\"\n  (setq popup (popup-create (point) 10 10))\n  (popup-set-list popup '(\"hello\" \"world\"))\n  (popup-draw popup))\n\n(ui-test \"hidden?\"\n  (setq popup (popup-create (point) 10 10))\n  (popup-set-list popup '(\"hello\" \"world\"))\n  (popup-draw popup)\n  (popup-hide popup))\n\n(ui-test \"isearch?\"\n  (setq popup (popup-create (point) 10 10))\n  (popup-set-list popup '(\"hello\" \"world\"))\n  (popup-draw popup)\n  (input ?e)\n  (popup-isearch popup))\n\n(ui-test \"tip?\"\n  (popup-tip\n   \"Start isearch on POPUP. This function is synchronized, meaning\nevent loop waits for quiting of isearch.\n\nCURSOR-COLOR is a cursor color during isearch. The default value\nis `popup-isearch-cursor-color'.\n\nKEYMAP is a keymap which is used when processing events during\nevent loop. The default value is `popup-isearch-keymap'.\n\nCALLBACK is a function taking one argument. `popup-isearch' calls\nCALLBACK, if specified, after isearch finished or isearch\ncanceled. The arguments is whole filtered list of items.\n\nHELP-DELAY is a delay of displaying helps.\"\n   :nowait t))\n\n(ui-test \"fold?\"\n  (let ((s (make-string (- (window-width) 3) ? )))\n    (insert s)\n    (setq popup (popup-tip \"long long long long line\" :nowait t))))\n\n(ui-test \"fold?\"\n  (let ((s (make-string (- (window-height) 3) ?\\n)))\n    (insert s)\n    (setq popup (popup-tip \"bla\\nbla\\nbla\\nbla\\nbla\" :nowait t))))\n\n(ui-test \"margin?\"\n  (setq popup (popup-tip \"Margin?\" :nowait t :margin t)))\n\n(ui-test \"two lines?\"\n  (setq popup (popup-tip \"Foo\\nBar\\nBaz\" :nowait t :height 2)))\n\n(ui-test \"scroll bar?\"\n  (setq popup (popup-tip \"Foo\\nBar\\nBaz\\nFez\\nOz\" :nowait t :height 3 :scroll-bar t :margin t)))\n\n(ui-test \"min-height?\"\n  (setq popup (popup-tip \"Hello\" :nowait t :min-height 10)))\n\n(ui-test \"menu?\"\n  (setq popup (popup-menu* '(\"Foo\" \"Bar\" \"Baz\") :nowait t)))\n\n(ui-test \"cascade menu?\"\n  (setq popup (popup-cascade-menu '((\"Foo\" \"Foo1\" \"Foo2\") \"Bar\" \"Baz\") :nowait t :margin t)))\n\n(ui-test \"next?\"\n  (setq popup (popup-cascade-menu '(\"Foo\" \"Bar\" \"Baz\") :nowait t :margin t))\n  (popup-next popup))\n\n(ui-test \"previous?\"\n  (setq popup (popup-cascade-menu '(\"Foo\" \"Bar\" \"Baz\") :nowait t :margin t))\n  (popup-previous popup))\n\n(ui-test \"select?\"\n  (setq popup (popup-cascade-menu '(\"Foo\" \"Bar\" \"Baz\") :nowait t :margin t))\n  (popup-select popup 1))\n\n(ui-test \"scroll-down?\"\n  (setq popup (popup-cascade-menu (loop repeat 100 collect \"Foo\") :nowait t :height 10 :margin t :scroll-bar t))\n  (popup-scroll-down popup 10))\n\n(ui-test \"scroll-up?\"\n  (setq popup (popup-cascade-menu (loop repeat 100 collect \"Foo\") :nowait t :height 10 :margin t :scroll-bar t))\n  (popup-scroll-down popup 999)\n  (popup-scroll-up popup 10))\n\n(message \"Congratulations!\")\n" "popup-interactive-test.el" nil nil nil nil nil nil)
		       ("popup-test.el" "(require 'ert)\n\n(require 'popup)\n\n(when (< (frame-width) (length \"long long long long line\"))\n  (set-frame-size (selected-frame) 80 35))\n\n(defmacro popup-test-with-common-setup (&rest body)\n  (declare (indent 0) (debug t))\n  `(save-excursion\n     (with-temp-buffer\n       (switch-to-buffer (current-buffer))\n       (delete-other-windows)\n       (erase-buffer)\n       ,@body\n       )))\n\n(defun popup-test-helper-line-move-visual (arg)\n  \"This function is workaround. Because `line-move-visual' can not work well in\nbatch mode.\"\n  (let ((cur-col\n         (- (current-column)\n            (save-excursion (vertical-motion 0) (current-column)))))\n    (vertical-motion arg)\n    (move-to-column (+ (current-column) cur-col))))\n\n(defun popup-test-helper-rectangle-match (str)\n  (let ((buffer-contents (popup-test-helper-buffer-contents)))\n    (with-temp-buffer\n      (insert buffer-contents)\n      (goto-char (point-min))\n      (let ((strings (split-string str \"\\n\")))\n        (when (search-forward (car strings) nil t)\n          (goto-char (match-beginning 0))\n          (cl-every\n           'identity\n           (mapcar\n            (lambda (elem)\n              (popup-test-helper-line-move-visual 1)\n              (looking-at (regexp-quote elem)))\n            (cdr strings))))))))\n\n(defun popup-test-helper-buffer-contents ()\n  (cl-loop with start = (point-min)\n        with contents\n        for overlay in (cl-sort (overlays-in (point-min) (point-max))\n                              '< :key 'overlay-start)\n        for overlay-start = (overlay-start overlay)\n        for overlay-end = (overlay-end overlay)\n        for prefix = (buffer-substring start overlay-start)\n        for befstr = (overlay-get overlay 'before-string)\n        for substr = (or (overlay-get overlay 'display)\n                         (buffer-substring overlay-start overlay-end))\n        for aftstr = (overlay-get overlay 'after-string)\n        collect prefix into contents\n        unless (overlay-get overlay 'invisible) collect\n        (concat befstr substr aftstr) into contents\n        do (setq start overlay-end)\n        finally (return (concat (apply 'concat contents)\n                                (buffer-substring start (point-max))))\n        ))\n\n(defun popup-test-helper-create-popup (str)\n  (setq popup (popup-create (point) 10 10))\n  (popup-set-list popup (split-string str \"\\n\"))\n  (popup-draw popup))\n\n(defun popup-test-helper-in-popup-p ()\n  (let* ((faces (get-text-property (point) 'face))\n         (faces (if (listp faces) faces (list faces))))\n    (or (memq 'popup-tip-face faces)\n        (memq 'popup-menu-face faces)\n        (memq 'popup-menu-selection-face faces)\n        (memq 'popup-face faces))))\n\n(defun popup-test-helper-popup-selected-item (str)\n  (let ((buffer-contents (popup-test-helper-buffer-contents)))\n    (with-temp-buffer\n      (insert buffer-contents)\n      (goto-char (point-min))\n      (goto-char\n       (text-property-any (point-min) (point-max)\n                          'face 'popup-menu-selection-face))\n      (looking-at str)\n      )))\n\n(defun popup-test-helper-popup-beginning-line ()\n  (let ((buffer-contents (popup-test-helper-buffer-contents)))\n    (with-temp-buffer\n      (insert buffer-contents)\n      (goto-char (point-min))\n      (let ((end (point)))\n        (while (and (not (eobp))\n                    (not (popup-test-helper-in-popup-p)))\n          (goto-char (or (next-single-property-change (point) 'face)\n                         (point-max))))\n        (if (popup-test-helper-in-popup-p)\n            ;; todo visual line\n            (line-number-at-pos (point)) nil)\n        ))))\n\n(defun popup-test-helper-popup-beginning-column ()\n  (let ((buffer-contents (popup-test-helper-buffer-contents)))\n    (with-temp-buffer\n      (insert buffer-contents)\n      (goto-char (point-min))\n      (let ((end (point)))\n        (while (and (not (eobp))\n                    (not (popup-test-helper-in-popup-p)))\n          (goto-char (or (next-single-property-change (point) 'face)\n                         (point-max))))\n        (if (popup-test-helper-in-popup-p)\n            (current-column) nil)\n        ))))\n\n(defun popup-test-helper-popup-end-line ()\n  (let ((buffer-contents (popup-test-helper-buffer-contents)))\n    (with-temp-buffer\n      (insert buffer-contents)\n      (goto-char (point-max))\n      (let ((end (point)))\n        (while (and (not (bobp))\n                    (not (popup-test-helper-in-popup-p)))\n          (setq end (point))\n          (goto-char (or (previous-single-property-change (point) 'face)\n                         (point-min))))\n        (if (popup-test-helper-in-popup-p)\n            ;; todo visual line\n            (line-number-at-pos end) nil)\n        ))))\n\n(defun popup-test-helper-popup-end-column ()\n  (let ((buffer-contents (popup-test-helper-buffer-contents)))\n    (with-temp-buffer\n      (insert buffer-contents)\n      (goto-char (point-max))\n      (let ((end (point)))\n        (while (and (not (bobp))\n                    (not (popup-test-helper-in-popup-p)))\n          (setq end (point))\n          (goto-char (or (previous-single-property-change (point) 'face)\n                         (point-min))))\n        (when (popup-test-helper-in-popup-p)\n          (goto-char end)\n          (current-column))\n        ))))\n\n(defun popup-test-helper-debug ()\n  (let ((buffer-contents (popup-test-helper-buffer-contents)))\n    (with-current-buffer (get-buffer-create \"*dump*\")\n      (erase-buffer)\n      (insert buffer-contents)\n      (buffer-string)\n      )))\n;; Test for helper method\n(ert-deftest popup-test-no-truncated ()\n  (popup-test-with-common-setup\n    (insert (make-string (- (window-width) 4) ? )) (insert \"Foo\\n\")\n    (insert (make-string (- (window-width) 4) ? )) (insert \"Bar\\n\")\n    (insert (make-string (- (window-width) 4) ? )) (insert \"Baz\\n\")\n    (should (eq t (popup-test-helper-rectangle-match \"\\\nFoo\nBar\nBaz\")))\n    ))\n\n(ert-deftest popup-test-truncated ()\n  (popup-test-with-common-setup\n    (insert (make-string (- (window-width) 2) ? )) (insert \"Foo\\n\")\n    (insert (make-string (- (window-width) 2) ? )) (insert \"Bar\\n\")\n    (insert (make-string (- (window-width) 2) ? )) (insert \"Baz\\n\")\n    (should (eq nil (popup-test-helper-rectangle-match \"\\\nFoo\nBar\nBaz\")))\n    ))\n\n(ert-deftest popup-test-misaligned ()\n  (popup-test-with-common-setup\n    (progn\n      (insert (make-string (- (window-width) 5) ? )) (insert \"Foo\\n\")\n      (insert (make-string (- (window-width) 4) ? )) (insert \"Bar\\n\")\n      (insert (make-string (- (window-width) 3) ? )) (insert \"Baz\\n\"))\n    (should (eq nil (popup-test-helper-rectangle-match \"\\\nFoo\nBar\nBaz\")))\n    ))\n;; Test for popup-el\n(ert-deftest popup-test-simple ()\n  (popup-test-with-common-setup\n    (popup-test-helper-create-popup \"\\\nfoo\nbar\nbaz\")\n    (should (popup-test-helper-rectangle-match \"\\\nfoo\nbar\nbaz\"))\n    (should (eq (popup-test-helper-popup-beginning-column) 0))))\n\n(ert-deftest popup-test-delete ()\n  (popup-test-with-common-setup\n    (popup-test-helper-create-popup \"\\\nfoo\nbar\nbaz\")\n    (popup-delete popup)\n    (should-not (popup-test-helper-rectangle-match \"\\\nfoo\nbar\nbaz\"))\n    ))\n\n(ert-deftest popup-test-hide ()\n  (popup-test-with-common-setup\n    (popup-test-helper-create-popup \"\\\nfoo\nbar\nbaz\")\n    (popup-hide popup)\n    (should-not (popup-test-helper-rectangle-match \"\\\nfoo\nbar\nbaz\"))\n    ))\n\n(ert-deftest popup-test-at-colum1 ()\n  (popup-test-with-common-setup\n    (insert \" \")\n    (popup-test-helper-create-popup \"\\\nfoo\nbar\nbaz\")\n    (should (popup-test-helper-rectangle-match \"\\\nfoo\nbar\nbaz\"))\n    (should (eq (popup-test-helper-popup-beginning-column) 1))\n    ))\n\n(ert-deftest popup-test-tip ()\n  (popup-test-with-common-setup\n    (popup-tip \"\\\nStart isearch on POPUP. This function is synchronized, meaning\nevent loop waits for quiting of isearch.\n\nCURSOR-COLOR is a cursor color during isearch. The default value\nis `popup-isearch-cursor-color'.\n\nKEYMAP is a keymap which is used when processing events during\nevent loop. The default value is `popup-isearch-keymap'.\n\nCALLBACK is a function taking one argument. `popup-isearch' calls\nCALLBACK, if specified, after isearch finished or isearch\ncanceled. The arguments is whole filtered list of items.\n\nHELP-DELAY is a delay of displaying helps.\"\n               :nowait t)\n    (should (popup-test-helper-rectangle-match \"\\\nKEYMAP is a keymap which is used when processing events during\nevent loop. The default value is `popup-isearch-keymap'.\"))\n    ))\n\n(ert-deftest popup-test-folding-long-line-right-top ()\n  (popup-test-with-common-setup\n    ;; To use window-width because Emacs 23 does not have window-body-width\n    (insert (make-string (- (window-width) 3) ? ))\n    (popup-tip \"long long long long line\" :nowait t)\n    (should (popup-test-helper-rectangle-match \"long long long long line\"))\n    (should (eq (popup-test-helper-popup-beginning-line)\n                2))\n    (should (eq (popup-test-helper-popup-end-line) 2))\n    ))\n\n(ert-deftest popup-test-folding-long-line-left-bottom ()\n  (popup-test-with-common-setup\n    (insert (make-string (- (window-body-height) 1) ?\\n))\n    (popup-tip \"long long long long line\" :nowait t)\n    (should (popup-test-helper-rectangle-match \"long long long long line\"))\n    (should (eq (popup-test-helper-popup-beginning-line)\n                (- (window-body-height) 1)))\n    (should (eq (popup-test-helper-popup-end-line) (- (window-body-height) 1)))\n    ))\n\n(ert-deftest popup-test-folding-long-line-right-bottom ()\n  (popup-test-with-common-setup\n    (insert (make-string (- (window-body-height) 1) ?\\n))\n    (insert (make-string (- (window-width) 3) ? ))\n    (popup-tip \"long long long long line\" :nowait t)\n    (should (popup-test-helper-rectangle-match \"long long long long line\"))\n    (should (eq (popup-test-helper-popup-beginning-line)\n                (- (window-body-height) 1)))\n    (should (eq (popup-test-helper-popup-end-line) (- (window-body-height) 1)))\n    ))\n\n(ert-deftest popup-test-folding-short-line-right-top ()\n  (popup-test-with-common-setup\n    (insert (make-string (- (window-width) 4) ? ))\n    (popup-tip \"\\\nbla\nbla\nbla\nbla\nbla\" :nowait t)\n    (should (popup-test-helper-rectangle-match \"\\\nbla\nbla\nbla\nbla\nbla\"))\n    (should (eq (popup-test-helper-popup-beginning-line) 2))\n    ))\n\n(ert-deftest popup-test-folding-short-line-left-bottom ()\n  (popup-test-with-common-setup\n    (insert (make-string (- (window-body-height) 1) ?\\n))\n    (popup-tip \"\\\nbla\nbla\nbla\nbla\nbla\" :nowait t)\n    (should (popup-test-helper-rectangle-match \"\\\nbla\nbla\nbla\nbla\nbla\"))\n    (should (eq (popup-test-helper-popup-end-line) (- (window-body-height) 1)))))\n\n(ert-deftest popup-test-folding-short-line-right-bottom ()\n  (popup-test-with-common-setup\n    (insert (make-string (- (window-body-height) 1) ?\\n))\n    (insert (make-string (- (window-width) 4) ? ))\n    (popup-tip \"\\\nbla\nbla\nbla\nbla\nbla\" :nowait t)\n    (should (popup-test-helper-rectangle-match \"\\\nbla\nbla\nbla\nbla\nbla\"))\n    (should (eq (popup-test-helper-popup-end-line) (- (window-body-height) 1)))\n    ))\n\n(ert-deftest popup-test-margin-at-column1 ()\n  (popup-test-with-common-setup\n    (insert \" \")\n    (popup-tip \"Margin?\" :nowait t :margin t)\n    (should (eq (popup-test-helper-popup-beginning-column)\n                0))\n    (should (popup-test-helper-rectangle-match \" Margin? \"))\n    ))\n\n(ert-deftest popup-test-margin-left ()\n  (popup-test-with-common-setup\n   (popup-tip \"Margin?\" :nowait t :margin t)\n   (should (eq (popup-test-helper-popup-beginning-column)\n               0))\n   ;; Pending: #19\n   ;; (should (popup-test-helper-rectangle-match \" Margin? \"))\n   ))\n\n(ert-deftest popup-test-margin-right ()\n  (popup-test-with-common-setup\n    (insert (make-string (- (window-width) 1) ? ))\n    (popup-tip \"Margin?\" :nowait t :margin t)\n    (should (popup-test-helper-rectangle-match \" Margin? \"))\n    ;; Pending: #19\n    ;; (should (< (popup-test-helper-popup-end-column) (window-width)))\n    ))\n\n(ert-deftest popup-test-height-limit ()\n  (popup-test-with-common-setup\n    (popup-tip \"\\\nFoo\nBar\nBaz\" :nowait t :height 2)\n    (should (popup-test-helper-rectangle-match \"\\\nFoo\nBar\"))\n    (should-not (popup-test-helper-rectangle-match \"Baz\"))\n    (should (eq (popup-test-helper-popup-beginning-line) 2))\n    (should (eq (popup-test-helper-popup-end-line)  3))\n    ))\n\n(ert-deftest popup-test-height-limit-bottom ()\n  (popup-test-with-common-setup\n    (insert (make-string (- (window-body-height) 1) ?\\n))\n    (popup-tip \"\\\nFoo\nBar\nBaz\" :nowait t :height 2)\n    (should (popup-test-helper-rectangle-match \"\\\nFoo\nBar\"))\n    (should-not (popup-test-helper-rectangle-match \"Baz\"))\n    (should (eq (popup-test-helper-popup-end-line) (- (window-body-height) 1)))\n    ))\n\n(ert-deftest popup-test-scroll-bar ()\n  (popup-test-with-common-setup\n    (let ((popup-scroll-bar-foreground-char\n           (propertize \"f\" 'face 'popup-scroll-bar-foreground-face))\n          (popup-scroll-bar-background-char\n           (propertize \"b\" 'face 'popup-scroll-bar-background-face)))\n      (popup-tip \"\\\nFoo\nBar\nBaz\nFez\nOz\"\n                 :nowait t :height 3 :scroll-bar t :margin t)\n      (should (popup-test-helper-rectangle-match \"\\\nFoo f\nBar b\nBaz b\"))\n      (should-not (popup-test-helper-rectangle-match \"Fez\"))\n      (should-not (popup-test-helper-rectangle-match \"Oz\"))\n      (should (eq (popup-test-helper-popup-beginning-line) 2))\n      (should (eq (popup-test-helper-popup-end-line)  4))\n      )))\n\n(ert-deftest popup-test-scroll-bar-right-no-margin ()\n  (popup-test-with-common-setup\n    (insert (make-string (- (window-width) 1) ? ))\n    (let ((popup-scroll-bar-foreground-char\n           (propertize \"f\" 'face 'popup-scroll-bar-foreground-face))\n          (popup-scroll-bar-background-char\n           (propertize \"b\" 'face 'popup-scroll-bar-background-face)))\n      (popup-tip \"\\\nFoo\nBar\nBaz\nFez\nOz\"\n                 :nowait t :height 3 :scroll-bar t)\n      (should (popup-test-helper-rectangle-match \"\\\nFoof\nBarb\nBazb\"))\n      (should-not (popup-test-helper-rectangle-match \"Fez\"))\n      (should-not (popup-test-helper-rectangle-match \"Oz\"))\n      (should (eq (popup-test-helper-popup-beginning-line) 2))\n      (should (eq (popup-test-helper-popup-end-line)  4))\n      )))\n\n(ert-deftest popup-test-scroll-bar-right-margin ()\n  (popup-test-with-common-setup\n    (insert (make-string (- (window-width) 1) ? ))\n    (let ((popup-scroll-bar-foreground-char\n           (propertize \"f\" 'face 'popup-scroll-bar-foreground-face))\n          (popup-scroll-bar-background-char\n           (propertize \"b\" 'face 'popup-scroll-bar-background-face)))\n      (popup-tip \"\\\nFoo\nBar\nBaz\nFez\nOz\"\n                 :nowait t :height 3 :scroll-bar t :margin t)\n      (should-not (popup-test-helper-rectangle-match \"Fez\"))\n      (should-not (popup-test-helper-rectangle-match \"Oz\"))\n      (should (eq (popup-test-helper-popup-beginning-line) 2))\n      (should (eq (popup-test-helper-popup-end-line)  4))\n      ;; Pending: #21\n      ;;       (should (popup-test-helper-rectangle-match \"\\\n      ;; Foof\n      ;; Barb\n      ;; Bazb\"))\n      )))\n\n(ert-deftest popup-test-min-height ()\n  (popup-test-with-common-setup\n    (insert (make-string (- (window-width) 1) ? ))\n    (popup-tip \"Hello\" :nowait t :min-height 10)\n    (should (popup-test-helper-rectangle-match \"Hello\"))\n    (should (eq (popup-test-helper-popup-beginning-line) 2))\n    (should (eq (popup-test-helper-popup-end-line) 11))\n    ))\n\n(ert-deftest popup-test-menu ()\n  (popup-test-with-common-setup\n    (popup-menu* '(\"Foo\" \"Bar\" \"Baz\") :nowait t)\n    (should (popup-test-helper-rectangle-match \"\\\nFoo\nBar\nBaz\"))\n    (should (eq (popup-test-helper-popup-beginning-line) 2))\n    ))\n\n(ert-deftest popup-test-cascade-menu ()\n  (popup-test-with-common-setup\n    (popup-cascade-menu\n     '((\"Foo\" \"Foo1\" \"Foo2\") \"Bar\" \"Baz\") :nowait t)\n    (should (popup-test-helper-rectangle-match \"Foo        >\"))\n    (should (popup-test-helper-rectangle-match \"\\\nFoo\nBar\nBaz\"))\n    (should-not (popup-test-helper-rectangle-match \"Foo1\"))\n    (should-not (popup-test-helper-rectangle-match \"Foo2\"))\n    (should (eq (popup-test-helper-popup-beginning-line) 2))\n    ))\n\n(ert-deftest popup-test-next ()\n  (popup-test-with-common-setup\n    (setq popup (popup-menu* '(\"Foo\" \"Bar\" \"Baz\") :nowait t))\n    (should (popup-test-helper-popup-selected-item \"Foo\"))\n    (popup-next popup)\n    (should (popup-test-helper-popup-selected-item \"Bar\"))\n    (popup-next popup)\n    (should (popup-test-helper-popup-selected-item \"Baz\"))\n    (popup-next popup)\n    (should (popup-test-helper-popup-selected-item \"Foo\"))\n    (should (popup-test-helper-rectangle-match \"Foo\\nBar\\nBaz\"))\n    (should (eq (popup-test-helper-popup-beginning-line) 2))\n    ))\n\n(ert-deftest popup-test-previous ()\n  (popup-test-with-common-setup\n    (setq popup (popup-menu* '(\"Foo\" \"Bar\" \"Baz\") :nowait t))\n    (should (popup-test-helper-popup-selected-item \"Foo\"))\n    (popup-previous popup)\n    (should (popup-test-helper-popup-selected-item \"Baz\"))\n    (popup-previous popup)\n    (should (popup-test-helper-popup-selected-item \"Bar\"))\n    (popup-previous popup)\n    (should (popup-test-helper-popup-selected-item \"Foo\"))\n    (should (popup-test-helper-rectangle-match \"\\\nFoo\nBar\nBaz\"))\n    (should (eq (popup-test-helper-popup-beginning-line) 2))\n    ))\n\n(ert-deftest popup-test-select ()\n  (popup-test-with-common-setup\n    (setq popup (popup-menu* '(\"Foo\" \"Bar\" \"Baz\") :nowait t))\n    (should (popup-test-helper-popup-selected-item \"Foo\"))\n    (popup-select popup 1)\n    (should (popup-test-helper-popup-selected-item \"Bar\"))\n    (popup-select popup 0)\n    (should (popup-test-helper-popup-selected-item \"Foo\"))\n    (popup-select popup 2)\n    (should (popup-test-helper-popup-selected-item \"Baz\"))\n    (should (popup-test-helper-rectangle-match \"\\\nFoo\nBar\nBaz\"))\n    (should (eq (popup-test-helper-popup-beginning-line) 2))\n    ))\n\n(ert-deftest popup-test-scroll-down ()\n  (popup-test-with-common-setup\n    (setq popup\n          (popup-cascade-menu (cl-loop for x to 100 collect (format \"Foo%d\" x))\n                              :nowait t :height 10 :margin t :scroll-bar t))\n    (should (popup-test-helper-rectangle-match \"\\\nFoo0\nFoo1\nFoo2\"))\n    (should (popup-test-helper-popup-selected-item \"Foo0\"))\n    (popup-scroll-down popup 10)\n    (should (popup-test-helper-popup-selected-item \"Foo10\"))\n    (popup-scroll-down popup 10)\n    (should (popup-test-helper-popup-selected-item \"Foo20\"))\n    (popup-scroll-down popup 100)\n    (should-not (popup-test-helper-rectangle-match \"Foo90\"))\n    (should (popup-test-helper-rectangle-match \"Foo91\"))\n    (should (popup-test-helper-rectangle-match \"Foo100\"))\n    (should-not (popup-test-helper-rectangle-match \"Foo0\"))\n    (should (eq (popup-test-helper-popup-beginning-line) 2))\n    ))\n\n(ert-deftest popup-test-scroll-up ()\n  (popup-test-with-common-setup\n    (setq popup\n          (popup-cascade-menu (cl-loop for x to 100 collect (format \"Foo%d\" x))\n                              :nowait t :height 10 :margin t :scroll-bar t))\n    (should (popup-test-helper-rectangle-match \"\\\nFoo0\nFoo1\nFoo2\"))\n    (should (popup-test-helper-popup-selected-item \"Foo0\"))\n    (popup-scroll-down popup 100)\n    (should (popup-test-helper-popup-selected-item \"Foo91\"))\n    (popup-scroll-up popup 10)\n    (should (popup-test-helper-popup-selected-item \"Foo81\"))\n    (popup-scroll-up popup 10)\n    (should-not (popup-test-helper-rectangle-match \"Foo70\"))\n    (should (popup-test-helper-rectangle-match \"Foo71\"))\n    (should (popup-test-helper-rectangle-match \"Foo80\"))\n    (should-not (popup-test-helper-rectangle-match \"Foo81\"))\n    (should (eq (popup-test-helper-popup-beginning-line) 2))\n    ))\n\n(ert-deftest popup-test-two-tip ()\n  (popup-test-with-common-setup\n   (popup-tip \"\\\nFoo\nBar\" :nowait t)\n   (save-excursion (insert \"\\n\"))\n   (popup-tip \"\\\nBaz\nQux\" :nowait t)\n   ;; Pending: #20\n   ;;    (should (popup-test-helper-rectangle-match \"\\\n   ;; Foo\n   ;; Bar\"))\n   ;;    (should (popup-test-helper-rectangle-match \"\\\n   ;; Baz\n   ;; Qux\"))\n   ))\n\n(ert-deftest popup-test-initial-index ()\n  (popup-test-with-common-setup\n    (setq popup (popup-menu* '(\"Foo\" \"Bar\" \"Baz\") :initial-index 0 :nowait t))\n    (should (popup-test-helper-popup-selected-item \"Foo\")))\n\n  (popup-test-with-common-setup\n    (setq popup (popup-menu* '(\"Foo\" \"Bar\" \"Baz\") :initial-index 2 :nowait t))\n    (should (popup-test-helper-popup-selected-item \"Baz\")))\n\n  (popup-test-with-common-setup\n    (setq popup (popup-menu* '(\"Foo\" \"Bar\" \"Baz\") :initial-index -1 :nowait t))\n    (should (popup-test-helper-popup-selected-item \"Foo\")))\n\n  (popup-test-with-common-setup\n    (setq popup (popup-menu* '(\"Foo\" \"Bar\" \"Baz\") :initial-index 100 :nowait t))\n    (should (popup-test-helper-popup-selected-item \"Baz\"))))\n\n(defun popup-test-helper-input (key)\n  (push key unread-command-events))\n\n(ert-deftest popup-test-isearch ()\n  (popup-test-with-common-setup\n    (popup-test-helper-create-popup \"\\\nfoo\nbar\nbaz\")\n    (popup-isearch-update popup \"a\")\n    (should (popup-test-helper-rectangle-match \"\\\nbar\nbaz\"))\n    (should-not (popup-test-helper-rectangle-match \"foo\"))\n    ))\n" "popup-test.el" nil nil nil nil nil nil)
		       ("run-test.el" ";; Usage:\n;;\n;;   cask exec emacs -Q -l tests/run-test.el           # interactive mode\n;;   cask exec emacs -batch -Q -l tests/run-test.el    # batch mode\n\n\n;; Utils\n(defun popup-test-join-path (path &rest rest)\n  \"Join a list of PATHS with appropriate separator (such as /).\n\n\\(fn &rest paths)\"\n  (if rest\n      (concat (file-name-as-directory path) (apply 'popup-test-join-path rest))\n    path))\n\n(defvar popup-test-dir (file-name-directory load-file-name))\n(defvar popup-root-dir (concat popup-test-dir \"..\"))\n\n\n;; Setup `load-path'\n(mapc (lambda (p) (add-to-list 'load-path p))\n      (list popup-test-dir\n            popup-root-dir))\n\n;; Load tests\n(load \"popup-test\")\n\n\n;; Run tests\n(if noninteractive\n    (ert-run-tests-batch-and-exit)\n  (ert t))\n" "run-test.el" nil nil nil nil nil nil)))


;;; Do not edit! File generated at Thu Jan  7 22:29:06 2016
